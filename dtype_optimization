### INSTRUCTIONS ###
# To execute the present script, load the datasets to be cleaned and then put them into a list of dataframes.
# We will call the dataframe list 'dflist', such that you must run first the following:
# dflist = [] <-- here you insert your dataframes and separate with commas. Once you're done, run the script below.


# Print initial memory usage details
mem_sum = 0
for i in dflist:
    print('Memory usage of dataframe is {:.6f} GB'.format(i.memory_usage().sum()/1000000000))
    mem_sum = mem_sum+i.memory_usage().sum()/1000000000
print(f"Total memory used for all dataframes is: {mem_sum:.2f}GB")

# Construct dataframe for reference used below in the optimize_inttypes function.
np_types = [np.int8 ,np.int16 ,np.int32, np.int64,
           np.uint8 ,np.uint16, np.uint32, np.uint64]
np_types = [np_type.__name__ for np_type in np_types]
type_df = pd.DataFrame(data=np_types, columns=['class_type'])
type_df['min_value'] = type_df['class_type'].apply(lambda row: np.iinfo(row).min)
type_df['max_value'] = type_df['class_type'].apply(lambda row: np.iinfo(row).max)
type_df['range'] = type_df['max_value'] - type_df['min_value']
type_df.sort_values(by='range', inplace=True)

# Create function to optimize integer data types
def optimize_inttypes(dataframe):
    for col in dataframe.loc[:, dataframe.dtypes <= np.int64]:
        col_min = dataframe[col].min()
        col_max = dataframe[col].max()
        temp = type_df[(type_df['min_value'] <= col_min) & (type_df['max_value'] >= col_max)]
        optimized_class = temp.loc[temp['range'].idxmin(), 'class_type']
        print("Col name : {} Col min_value : {} Col max_value : {} Optimized Class : {}".format(col, col_min, col_max, optimized_class))
        dataframe[col] = dataframe[col].astype(optimized_class)

# Run integer optimization over all dataframes.
for i in dflist:
    optimize_inttypes(i)

# Print updated memory usage details
mem_sum = 0
for i in dflist:
    print('Memory usage of dataframe is {:.6f} GB'.format(i.memory_usage().sum()/1000000000))
    mem_sum = mem_sum+i.memory_usage().sum()/1000000000
print(f"Total memory used for all dataframes is: {mem_sum:.2f}GB")

####################################################################################################
####################################################################################################

# Create dataframe for reference, used in the float optimization function further below.
np_types = [np.float16 ,np.float32, np.float64]
np_types = [np_type.__name__ for np_type in np_types]
floattype_df = pd.DataFrame(data=np_types, columns=['class_type'])
floattype_df['min_value'] = floattype_df['class_type'].apply(lambda row: np.finfo(row).min)
floattype_df['max_value'] = floattype_df['class_type'].apply(lambda row: np.finfo(row).max)
floattype_df['range'] = floattype_df['max_value'] - floattype_df['min_value']
floattype_df.sort_values(by='range', inplace=True)

# Create float optimization function.
def optimize_floattypes(dataframe):
    for col in dataframe.loc[:, dataframe.dtypes == np.float64]:
        col_min = dataframe[col].min()
        col_max = dataframe[col].max()
        temp = floattype_df[(floattype_df['min_value'] <= col_min) & (floattype_df['max_value'] >= col_max)]
        optimized_class = temp.loc[temp['range'].idxmin(), 'class_type']
        print("Col name : {} Col min_value : {} Col max_value : {} Optimized Class : {}".format(col, col_min, col_max, optimized_class))
        dataframe[col] = dataframe[col].astype(optimized_class)

# Run float optimization over all dataframes.
for i in dflist:
    optimize_floattypes(i)

# Print updated memory usage details
mem_sum = 0
for i in dflist:
    print('Memory usage of dataframe is {:.6f} GB'.format(i.memory_usage().sum()/1000000000))
    mem_sum = mem_sum+i.memory_usage().sum()/1000000000
print(f"Total memory used for all dataframes is: {mem_sum:.2f}GB")